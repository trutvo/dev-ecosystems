# -*- org-confirm-babel-evaluate: nil -*-
#+TITLE: meta programming

Meta programming is a programming technique in which computer programs have the ability
to treat other programs as their data. This means that a program can be designed to read,
generate, analyze, or transform other programs, and even modify itself while running.

* Lisp

In lisp data and code are represented in the same way: as lists. This makes lisp a powerful language for
meta programming, because lisp programs can easily manipulate other lisp programs.

#+BEGIN_SRC emacs-lisp
  (defvar myfunc (quote (+ 1 3 4)))
  (defvar myfunc2 (append myfunc '(5)))
  (message "data=%s\nexecuted code=%s" myfunc2 (eval myfunc2))
#+END_SRC

#+RESULTS:
: data=(+ 1 3 4 5)
: executed code=13

* Python

In script languages like python reflect of code is used very often.


#+BEGIN_SRC python :session :exports both :results value :tangle example_meta_programming_worker.py
  out = ""

  def echo(msg):
    global out
    out += msg + "\n"

  class Worker:
    def do_work(self):
      return self.__class__.__name__ + ": Doing work..."

  class ClosableWorker(Worker):
    def do_work(self):
      return self.__class__.__name__ + ": Doing work..."
    def close(self):
      return self.__class__.__name__ + ": close"

  def run_worker(w):
    echo(w.do_work())
    if hasattr(w, 'close') and callable(getattr(w, 'close')):
      echo(w.close())

  w = Worker()
  run_worker(w)
  cw = ClosableWorker()
  run_worker(cw)
  out

#+END_SRC

#+RESULTS:
: Worker: Doing work...
: ClosableWorker: Doing work...
: ClosableWorker: close

A common pattern is to use decorators to add functionality to functions or methods.
In this example, we create a simple transaction decorator that adds transaction management
to functions that perform database operations.

#+BEGIN_SRC python :session :exports both :results value :tangle example_meta_programming_trx.py
  out = ""

  def echo(msg):
    global out
    out += msg + "\n"

  class DatabaseConnection:
   def begin(self):
     echo("DB: begin transaction")
     pass
   def rollback(self):
     echo("DB: rollback transaction")
     pass
   def commit(self):
     echo("DB: commit transaction")
     pass

  db = DatabaseConnection()

  def transactional(func):
    def wrapper():
      db.begin()
      try:
        func()
        db.commit()
      except Exception as e:
        db.rollback()
        raise e
    return wrapper

  @transactional
  def say_hello():
    echo("Hello!")

  @transactional
  def fail():
    1 / 0

  try:
    echo("---")
    say_hello()
    echo("---")
    fail()
  except Exception as e:
    echo(f"ERROR: Caught exception: {e}")
  print(out)
  out
#+END_SRC

#+RESULTS:
: ---
: DB: begin transaction
: Hello!
: DB: commit transaction
: ---
: DB: begin transaction
: DB: rollback transaction
: ERROR: Caught exception: division by zero


* Java

A typical example of meta programming in Java is loading classes dynamically at runtime using reflection.
In this example, we load a JDBC driver class dynamically. This is often used in application servers.

#+BEGIN_SRC java :exports both :results silent :tangle LoadDriverExample.java
  import java.lang.reflect.Method;

  public class LoadDriverExample {
    public static void main(String[] args) {
      try {
        // Load the JDBC driver class dynamically
        //Class<?> driverClass = Class.forName("com.mysql.cj.jdbc.Driver");
        Class<?> driverClass = Class.forName("java.sql.Driver");
        Method method = driverClass.getMethod("connect", String.class, java.util.Properties.class);
        System.out.println("Driver class loaded: " + driverClass.getName());
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }
#+END_SRC

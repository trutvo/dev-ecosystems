# -*- org-confirm-babel-evaluate: nil -*-
#+TITLE: meta programming

Meta programming is a programming technique in which computer programs have the ability
to treat other programs as their data. This means that a program can be designed to read,
generate, analyze, or transform other programs, and even modify itself while running.

* Meta programming with Interpreter Languages

** Lisp

In lisp data and code are represented in the same way: as lists. This makes lisp a powerful language for
meta programming, because lisp programs can easily manipulate other lisp programs.

#+BEGIN_SRC emacs-lisp
  (defvar myfunc (quote (+ 1 3 4)))
  (defvar myfunc2 (append myfunc '(5)))
  (message "data=%s\nexecuted code=%s" myfunc2 (eval myfunc2))
#+END_SRC

#+RESULTS:
: data=(+ 1 3 4 5)
: executed code=13

** Python

In script languages like python reflect of code is used very often.


#+BEGIN_SRC python :session :exports both :results value :tangle example_meta_programming_worker.py
  out = ""

  def echo(msg):
    global out
    out += msg + "\n"

  class Worker:
    def do_work(self):
      return self.__class__.__name__ + ": Doing work..."

  class ClosableWorker(Worker):
    def do_work(self):
      return self.__class__.__name__ + ": Doing work..."
    def close(self):
      return self.__class__.__name__ + ": close"

  def run_worker(w):
    echo(w.do_work())
    if hasattr(w, 'close') and callable(getattr(w, 'close')):
      echo(w.close())

  w = Worker()
  run_worker(w)
  cw = ClosableWorker()
  run_worker(cw)
  out

#+END_SRC

#+RESULTS:
: Worker: Doing work...
: ClosableWorker: Doing work...
: ClosableWorker: close

A common pattern is to use decorators to add functionality to functions or methods.
In this example, we create a simple transaction decorator that adds transaction management
to functions that perform database operations.

#+BEGIN_SRC python :session :exports both :results value :tangle example_meta_programming_trx.py
  out = ""

  def echo(msg):
    global out
    out += msg + "\n"

  class DatabaseConnection:
   def begin(self):
     echo("DB: begin transaction")
     pass
   def rollback(self):
     echo("DB: rollback transaction")
     pass
   def commit(self):
     echo("DB: commit transaction")
     pass

  db = DatabaseConnection()

  def transactional(func):
    def wrapper():
      db.begin()
      try:
        func()
        db.commit()
      except Exception as e:
        db.rollback()
        raise e
    return wrapper

  @transactional
  def say_hello():
    echo("Hello!")

  @transactional
  def fail():
    1 / 0

  try:
    echo("---")
    say_hello()
    echo("---")
    fail()
  except Exception as e:
    echo(f"ERROR: Caught exception: {e}")
  print(out)
  out
#+END_SRC

#+RESULTS:
: ---
: DB: begin transaction
: Hello!
: DB: commit transaction
: ---
: DB: begin transaction
: DB: rollback transaction
: ERROR: Caught exception: division by zero


* Meta programming with Java

In java you can do the same pattern as in python by using annotations.

#+BEGIN_SRC java  :results silent
  @Transactional
  public void processEvent(Long reviewId) {
    ...
  }
#+END_SRC

They look the same as the pyhon decorators, but work differently.
In comparison to python, java needs to use the reflection API to read this annotation at runtime. 
Java programmers have to write the code that is doing the annotation processing themselves or use a framework that does this for them (like Spring).

See: https://www.baeldung.com/java-dynamic-proxies

** Dynamic Modules

A typical example of meta programming in Java is loading classes dynamically at runtime using reflection.
In this example, we load a JDBC driver class dynamically. This is often used in application servers.

#+BEGIN_SRC java :exports both :results both :tangle LoadDriverExample.java
  import java.lang.reflect.Method;

  public class LoadDriverExample {
    public static void main(String[] args) {
      try {
        // Load the JDBC driver class dynamically
        //Class<?> driverClass = Class.forName("com.mysql.cj.jdbc.Driver");
        Class<?> driverClass = Class.forName("java.sql.Driver");
        Method method = driverClass.getMethod("connect", String.class, java.util.Properties.class);
        System.out.println("Driver class loaded: " + driverClass.getName());
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }
#+END_SRC

#+RESULTS:
: Driver class loaded: java.sql.Driver

* Meta programming with C/C++

In C/C++ meta programming is often done at compile time using templates and macros.

#+BEGIN_SRC cpp :exports both :results value :tangle meta_programming.cpp
  #include <iostream>
  #include <type_traits>

  // A simple meta-program that computes the factorial of a number at compile time
  template<int N>
  struct Factorial {
	static const int value = N * Factorial<N - 1>::value;
  };

  template<>
  struct Factorial<0> {
	static const int value = 1;
  };

  int main() {
	std::cout << "Factorial of 5: " << Factorial<5>::value << std::endl;
	return 0;
  }
#+END_SRC
